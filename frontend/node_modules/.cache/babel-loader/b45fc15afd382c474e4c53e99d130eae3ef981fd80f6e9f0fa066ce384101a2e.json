{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\rucha\\\\Life-Tag\\\\frontend\\\\src\\\\components\\\\CountdownTimer.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport './CountdownTimer.css'; // We'll create this next\n\n// We accept two props:\n// 1. expiresAt: The ISO 8601 timestamp from the backend\n// 2. onExpire: A function to call when the timer hits zero\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CountdownTimer = ({\n  expiresAt,\n  onExpire\n}) => {\n  _s();\n  const [timeLeft, setTimeLeft] = useState('');\n  useEffect(() => {\n    // 1. Set up an interval to run every second\n    const intervalId = setInterval(() => {\n      const now = new Date().getTime();\n      const expiryTime = new Date(expiresAt).getTime();\n      const distance = expiryTime - now;\n\n      // 2. If the distance is negative, the timer is done\n      if (distance < 0) {\n        clearInterval(intervalId);\n        setTimeLeft('Expired');\n        // If onExpire is provided, call it to refresh the list\n        if (onExpire) {\n          onExpire();\n        }\n        return;\n      }\n\n      // 3. Calculate minutes and seconds\n      const minutes = Math.floor(distance % (1000 * 60 * 60) / (1000 * 60));\n      const seconds = Math.floor(distance % (1000 * 60) / 1000);\n\n      // 4. Format the string (e.g., \"14:03\")\n      const formattedTime = String(minutes).padStart(2, '0') + ':' + String(seconds).padStart(2, '0');\n      setTimeLeft(formattedTime);\n    }, 1000);\n\n    // 5. Clean up the interval when the component is unmounted\n    return () => clearInterval(intervalId);\n  }, [expiresAt, onExpire]); // Re-run if these props change\n\n  // 6. Render the timer\n  return /*#__PURE__*/_jsxDEV(\"span\", {\n    className: `timer-badge ${timeLeft === 'Expired' ? 'expired' : 'active'}`,\n    children: timeLeft || 'Calculating...'\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 47,\n    columnNumber: 5\n  }, this);\n};\n_s(CountdownTimer, \"+/rc1qCbzmIsyWx4idJnN9XKwiM=\");\n_c = CountdownTimer;\nexport default CountdownTimer;\nvar _c;\n$RefreshReg$(_c, \"CountdownTimer\");","map":{"version":3,"names":["React","useState","useEffect","jsxDEV","_jsxDEV","CountdownTimer","expiresAt","onExpire","_s","timeLeft","setTimeLeft","intervalId","setInterval","now","Date","getTime","expiryTime","distance","clearInterval","minutes","Math","floor","seconds","formattedTime","String","padStart","className","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/rucha/Life-Tag/frontend/src/components/CountdownTimer.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\r\nimport './CountdownTimer.css'; // We'll create this next\r\n\r\n// We accept two props:\r\n// 1. expiresAt: The ISO 8601 timestamp from the backend\r\n// 2. onExpire: A function to call when the timer hits zero\r\nconst CountdownTimer = ({ expiresAt, onExpire }) => {\r\n  const [timeLeft, setTimeLeft] = useState('');\r\n\r\n  useEffect(() => {\r\n    // 1. Set up an interval to run every second\r\n    const intervalId = setInterval(() => {\r\n      const now = new Date().getTime();\r\n      const expiryTime = new Date(expiresAt).getTime();\r\n      const distance = expiryTime - now;\r\n\r\n      // 2. If the distance is negative, the timer is done\r\n      if (distance < 0) {\r\n        clearInterval(intervalId);\r\n        setTimeLeft('Expired');\r\n        // If onExpire is provided, call it to refresh the list\r\n        if (onExpire) {\r\n          onExpire();\r\n        }\r\n        return;\r\n      }\r\n\r\n      // 3. Calculate minutes and seconds\r\n      const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));\r\n      const seconds = Math.floor((distance % (1000 * 60)) / 1000);\r\n\r\n      // 4. Format the string (e.g., \"14:03\")\r\n      const formattedTime = \r\n        String(minutes).padStart(2, '0') + ':' + String(seconds).padStart(2, '0');\r\n      \r\n      setTimeLeft(formattedTime);\r\n\r\n    }, 1000);\r\n\r\n    // 5. Clean up the interval when the component is unmounted\r\n    return () => clearInterval(intervalId);\r\n\r\n  }, [expiresAt, onExpire]); // Re-run if these props change\r\n\r\n  // 6. Render the timer\r\n  return (\r\n    <span className={`timer-badge ${timeLeft === 'Expired' ? 'expired' : 'active'}`}>\r\n      {timeLeft || 'Calculating...'}\r\n    </span>\r\n  );\r\n};\r\n\r\nexport default CountdownTimer;"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAClD,OAAO,sBAAsB,CAAC,CAAC;;AAE/B;AACA;AACA;AAAA,SAAAC,MAAA,IAAAC,OAAA;AACA,MAAMC,cAAc,GAAGA,CAAC;EAAEC,SAAS;EAAEC;AAAS,CAAC,KAAK;EAAAC,EAAA;EAClD,MAAM,CAACC,QAAQ,EAAEC,WAAW,CAAC,GAAGT,QAAQ,CAAC,EAAE,CAAC;EAE5CC,SAAS,CAAC,MAAM;IACd;IACA,MAAMS,UAAU,GAAGC,WAAW,CAAC,MAAM;MACnC,MAAMC,GAAG,GAAG,IAAIC,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC;MAChC,MAAMC,UAAU,GAAG,IAAIF,IAAI,CAACR,SAAS,CAAC,CAACS,OAAO,CAAC,CAAC;MAChD,MAAME,QAAQ,GAAGD,UAAU,GAAGH,GAAG;;MAEjC;MACA,IAAII,QAAQ,GAAG,CAAC,EAAE;QAChBC,aAAa,CAACP,UAAU,CAAC;QACzBD,WAAW,CAAC,SAAS,CAAC;QACtB;QACA,IAAIH,QAAQ,EAAE;UACZA,QAAQ,CAAC,CAAC;QACZ;QACA;MACF;;MAEA;MACA,MAAMY,OAAO,GAAGC,IAAI,CAACC,KAAK,CAAEJ,QAAQ,IAAI,IAAI,GAAG,EAAE,GAAG,EAAE,CAAC,IAAK,IAAI,GAAG,EAAE,CAAC,CAAC;MACvE,MAAMK,OAAO,GAAGF,IAAI,CAACC,KAAK,CAAEJ,QAAQ,IAAI,IAAI,GAAG,EAAE,CAAC,GAAI,IAAI,CAAC;;MAE3D;MACA,MAAMM,aAAa,GACjBC,MAAM,CAACL,OAAO,CAAC,CAACM,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,GAAG,GAAG,GAAGD,MAAM,CAACF,OAAO,CAAC,CAACG,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;MAE3Ef,WAAW,CAACa,aAAa,CAAC;IAE5B,CAAC,EAAE,IAAI,CAAC;;IAER;IACA,OAAO,MAAML,aAAa,CAACP,UAAU,CAAC;EAExC,CAAC,EAAE,CAACL,SAAS,EAAEC,QAAQ,CAAC,CAAC,CAAC,CAAC;;EAE3B;EACA,oBACEH,OAAA;IAAMsB,SAAS,EAAE,eAAejB,QAAQ,KAAK,SAAS,GAAG,SAAS,GAAG,QAAQ,EAAG;IAAAkB,QAAA,EAC7ElB,QAAQ,IAAI;EAAgB;IAAAmB,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACzB,CAAC;AAEX,CAAC;AAACvB,EAAA,CA5CIH,cAAc;AAAA2B,EAAA,GAAd3B,cAAc;AA8CpB,eAAeA,cAAc;AAAC,IAAA2B,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}